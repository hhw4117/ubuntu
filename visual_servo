import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from std_msgs.msg import String
import math

class VisualServo(Node):
    def __init__(self):
        super().__init__('visual_servo_node')

        # ì…ë ¥: ì¹´ë©”ë¼ íŠ¸ë˜í‚¹ (msg.x=err_x(px), msg.z=depth(mm or -1))
        self.subscription = self.create_subscription(
            Point,
            '/camera/tracking',
            self.camera_callback,
            10
        )

        # ì¶œë ¥: STM32 ëª…ë ¹ ("1 45.50" í˜•ì‹)
        self.publisher_ = self.create_publisher(String, '/stm32/joint', 10)

        # ìƒíƒœ
        self.current_j1_angle = 0.0

        # ===== íŠœë‹ íŒŒë¼ë¯¸í„° =====
        self.kp = 0.008              # err_x(px) -> delta_angle(deg) ë¹„ë¡€ê³„ìˆ˜ (ë°©í–¥ì€ +ë¡œ ë§ì¶˜ ìƒíƒœ)
        self.DEADBAND_PX = 10        # ì´ í”½ì…€ ì´ë‚´ë©´ ì •ë ¬ë¡œ ë³´ê³  ì›€ì§ì´ì§€ ì•ŠìŒ
        self.MAX_STEP_DEG = 0.3      # í”„ë ˆì„(ì½œë°±)ë‹¹ ìµœëŒ€ íšŒì „ëŸ‰ ì œí•œ(ì˜¤ë²„ìŠˆíŠ¸ ë°©ì§€)
        self.J1_MIN_DEG = -90.0
        self.J1_MAX_DEG = 90.0

        # err_x EMA(ë…¸ì´ì¦ˆ ì™„í™”)
        self.alpha = 0.3             # 0.2~0.5
        self.err_ema = 0.0
        self.ema_inited = False

        # íƒ€ê²Ÿ ë¡œìŠ¤íŠ¸ ì²˜ë¦¬
        self.last_seen_time = self.get_clock().now()
        self.LOST_TIMEOUT_SEC = 0.25  # ì´ ì‹œê°„ ì´ìƒ íƒ€ê²Ÿì´ ì—†ìœ¼ë©´ "íƒìƒ‰" ëª¨ë“œ
        self.search_dir = 1.0
        self.SEARCH_STEP_DEG = 0.25   # íƒìƒ‰ ì‹œ í•œ ë²ˆì— ì›€ì§ì´ëŠ” ê°ë„
        self.SEARCH_HZ_LIMIT = 20.0   # íƒìƒ‰ ì¤‘ ë„ˆë¬´ ë¹ ë¥´ê²Œ publishí•˜ì§€ ì•Šë„ë¡
        self.last_pub_time = self.get_clock().now()

        # depthë¥¼ ê±°ë¦¬ê°’ìœ¼ë¡œë§Œ ì“°ê³ , "LOCKED" íŒë‹¨ì€ err_xë¡œë§Œ í•©ë‹ˆë‹¤.
        # (depth > 0ì´ë©´ return ê°™ì€ ë™ì‘ ì œê±°)

    @staticmethod
    def clamp(v, lo, hi):
        return lo if v < lo else hi if v > hi else v

    def publish_j1(self):
        cmd_str = f"1 {self.current_j1_angle:.2f}"
        msg_out = String()
        msg_out.data = cmd_str
        self.publisher_.publish(msg_out)
        return cmd_str

    def do_search(self, now):
        # íƒìƒ‰ publish ì£¼íŒŒìˆ˜ ì œí•œ
        dt = (now - self.last_pub_time).nanoseconds * 1e-9
        if dt < (1.0 / self.SEARCH_HZ_LIMIT):
            return

        self.current_j1_angle += self.search_dir * self.SEARCH_STEP_DEG

        # ëì— ë‹¿ìœ¼ë©´ ë°©í–¥ ë°˜ì „
        if self.current_j1_angle >= self.J1_MAX_DEG:
            self.current_j1_angle = self.J1_MAX_DEG
            self.search_dir *= -1.0
        elif self.current_j1_angle <= self.J1_MIN_DEG:
            self.current_j1_angle = self.J1_MIN_DEG
            self.search_dir *= -1.0

        cmd_str = self.publish_j1()
        self.last_pub_time = now
        self.get_logger().info(f"ğŸ›°ï¸ SEARCHING... {cmd_str}")

    def camera_callback(self, msg: Point):
        now = self.get_clock().now()

        err_x = float(msg.x)
        depth = float(msg.z)

        # ===== íƒ€ê²Ÿ ì¡´ì¬ íŒì • =====
        # ì‚¬ìš© ì¤‘ì¸ íŠ¸ë˜í‚¹ ì½”ë“œê°€ "ì—†ìŒ"ì„ (err_x=0, depth=-1)ë¡œ ë³´ë‚´ëŠ” ì¼€ì´ìŠ¤ ëŒ€ì‘
        target_visible = not (depth == -1.0 and err_x == 0.0)

        if not target_visible:
            # ë§ˆì§€ë§‰ìœ¼ë¡œ íƒ€ê²Ÿì„ ë³¸ ì‹œì  ê¸°ì¤€ìœ¼ë¡œ ì¼ì •ì‹œê°„ ì§€ë‚˜ë©´ íƒìƒ‰
            dt_lost = (now - self.last_seen_time).nanoseconds * 1e-9
            if dt_lost >= self.LOST_TIMEOUT_SEC:
                self.do_search(now)
            return

        # íƒ€ê²Ÿ ë³´ì„ ì—…ë°ì´íŠ¸
        self.last_seen_time = now

        # ===== ë…¸ì´ì¦ˆ ì™„í™”(EMA) =====
        if not self.ema_inited:
            self.err_ema = err_x
            self.ema_inited = True
        else:
            self.err_ema = self.alpha * err_x + (1.0 - self.alpha) * self.err_ema

        use_err = self.err_ema

        # ===== ì •ë ¬(LOCK) íŒë‹¨ì€ err_x ê¸°ë°˜ =====
        if abs(use_err) <= self.DEADBAND_PX:
            # í•„ìš”í•˜ë©´ ê±°ë¦¬ ë¡œê·¸ë§Œ ì°ê¸°(ì œì–´ëŠ” ë©ˆì¶¤)
            if depth > 0:
                self.get_logger().info(f"âœ… LOCKED (err_xâ‰ˆ0). Distance: {depth:.0f}mm")
            return

        # ===== P ì œì–´(ë°©í–¥ ì´ë¯¸ ë§ì¶˜ ìƒíƒœ) =====
        delta_angle = use_err * self.kp

        # í”„ë ˆì„ë‹¹ ë³€í™”ëŸ‰ ì œí•œ(ì˜¤ë²„ìŠˆíŠ¸ ë°©ì§€)
        delta_angle = self.clamp(delta_angle, -self.MAX_STEP_DEG, self.MAX_STEP_DEG)

        # ê°ë„ ëˆ„ì  ì—…ë°ì´íŠ¸ + ë²”ìœ„ ì œí•œ
        self.current_j1_angle += delta_angle
        self.current_j1_angle = self.clamp(self.current_j1_angle, self.J1_MIN_DEG, self.J1_MAX_DEG)

        cmd_str = self.publish_j1()
        self.get_logger().info(
            f"ğŸ”„ Adjusting J1: {cmd_str} (err_x={err_x:.1f}, ema={use_err:.1f}, d={depth:.0f})"
        )

def main(args=None):
    rclpy.init(args=args)
    node = VisualServo()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
