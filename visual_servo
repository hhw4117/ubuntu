import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from std_msgs.msg import String
from rclpy.qos import qos_profile_sensor_data
import time

print("âœ… [ì‹œìŠ¤í…œ] Visual Servo (ê±°ë¦¬ ì¸¡ì • + ìŠ¤ë§ˆíŠ¸ ì¶”ì ) ê°€ë™...")

class VisualServo(Node):
    def __init__(self):
        super().__init__('visual_servo_node')

        self.subscription = self.create_subscription(
            Point, '/camera/tracking', self.camera_callback, qos_profile_sensor_data
        )
        self.publisher_ = self.create_publisher(String, '/stm32/joint', 10)

        self.current_j1_angle = 0.0   
        self.J1_MIN_DEG = -90.0
        self.J1_MAX_DEG = 90.0

        # ===== íŠœë‹ íŒŒë¼ë¯¸í„° =====
        self.DEADBAND_PX = 10         # [ìˆ˜ì •] 20 -> 10 (ë” ì •ë°€í•˜ê²Œ ë©ˆì¶¤)

        # ì†ë„/ë³´í­ ì„¤ì •
        self.SPD_FAST   = 800         
        self.SPD_MID    = 1500        
        self.SPD_SLOW   = 2500        

        self.STEP_BIG   = 0.5         
        self.STEP_MID   = 0.2         
        self.STEP_TINY  = 0.05        

        self.CMD_INTERVAL = 0.04      
        self.k_step = 0.003           

        self.alpha = 0.6
        self.err_ema = 0.0
        self.ema_inited = False

        self.last_pub_time = 0.0
        self.state = 'IDLE'
        self.last_dist_print_time = 0.0 # ê±°ë¦¬ ì¶œë ¥ìš© íƒ€ì´ë¨¸

        print("âœ… ì´ˆê¸°í™” ì™„ë£Œ. ì»µì„ ë³´ì—¬ì£¼ì„¸ìš”!")

    def publish(self, s: str):
        m = String()
        m.data = s
        self.publisher_.publish(m)

    def clamp(self, v, lo, hi):
        return lo if v < lo else hi if v > hi else v

    def get_adaptive_params(self, error_px):
        abs_e = abs(error_px)
        if abs_e > 150: return self.SPD_FAST, self.STEP_BIG
        elif abs_e > 60: return self.SPD_MID, self.STEP_MID
        else: return self.SPD_SLOW, self.STEP_TINY

    def camera_callback(self, msg: Point):
        now = time.time()
        if (now - self.last_pub_time) < self.CMD_INTERVAL:
            return

        err_x = float(msg.x)
        depth = float(msg.z) # ì¹´ë©”ë¼ì—ì„œ ì˜¤ëŠ” ê±°ë¦¬ê°’ (ë‹¨ìœ„ í™•ì¸ í•„ìš”, ë³´í†µ mm)

        # íƒ€ê²Ÿ ì—†ìŒ
        if depth == -1.0 and err_x == 0.0:
            if self.state != 'IDLE':
                print("âš ï¸ íƒ€ê²Ÿ ë†“ì¹¨ (ëŒ€ê¸°)")
                self.state = 'IDLE'
            return

        # EMA í•„í„°
        if not self.ema_inited:
            self.err_ema = err_x
            self.ema_inited = True
        else:
            self.err_ema = self.alpha * err_x + (1.0 - self.alpha) * self.err_ema
        e = self.err_ema

        # ============================================================
        # [í•µì‹¬] ì •ë ¬ ì™„ë£Œ (LOCKED) ì‹œ ê±°ë¦¬ ì¶œë ¥
        # ============================================================
        if abs(e) <= self.DEADBAND_PX:
            
            # 1. ë§‰ ë„ì°©í–ˆì„ ë•Œ (MOVING -> LOCKED)
            if self.state != 'LOCKED':
                self.publish("STOP")
                
                # ê±°ë¦¬ ì •ë³´ ì˜ˆì˜ê²Œ ë§Œë“¤ê¸°
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                print(f"ğŸ›‘ ì •ë ¬ ì™„ë£Œ! [ê±°ë¦¬: {dist_str}] (Err: {e:.1f})")
                
                self.state = 'LOCKED'
                self.last_dist_print_time = now
            
            # 2. ë©ˆì¶°ìˆëŠ” ë™ì•ˆì—ë„ ê±°ë¦¬ê°€ ë°”ë€Œë©´ ê³„ì† ë³´ì—¬ì¤„ê¹Œ? (1ì´ˆë§ˆë‹¤ ê°±ì‹ )
            elif (now - self.last_dist_print_time) > 1.0:
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                print(f"ğŸ“ í˜„ì¬ ê±°ë¦¬: {dist_str}")
                self.last_dist_print_time = now

            self.last_pub_time = now
            return

        # ============================================================

        # ì¬ì¶”ê²©
        if self.state == 'LOCKED':
            print(f"ğŸƒ ì›€ì§ì„ ê°ì§€! ì¬ì¶”ê²© (Err: {e:.1f})")
        self.state = 'MOVING'

        direction = 1.0 if e > 0 else -1.0 
        cur_spd, cur_step_limit = self.get_adaptive_params(e)

        raw_step = abs(e) * self.k_step
        final_step = self.clamp(raw_step, 0.02, cur_step_limit)
        delta_deg = direction * final_step

        self.current_j1_angle += delta_deg
        self.current_j1_angle = self.clamp(self.current_j1_angle, self.J1_MIN_DEG, self.J1_MAX_DEG)

        cmd_str = f"T1 {self.current_j1_angle:.3f} {cur_spd}"
        self.publish(cmd_str)
        
        self.last_pub_time = now

def main(args=None):
    rclpy.init(args=args)
    node = VisualServo()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
