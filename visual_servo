import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from std_msgs.msg import String
from rclpy.qos import qos_profile_sensor_data
import time

print("âœ… [ì‹œìŠ¤í…œ] Visual Servo (ì§„ì§œ ì •ë°€ ëª¨ë“œ: ë§ˆì°°ë ¥ ë³´ìƒ) ê°€ë™...")

class VisualServo(Node):
    def __init__(self):
        super().__init__('visual_servo_node')
        self.subscription = self.create_subscription(
            Point, '/camera/tracking', self.camera_callback, qos_profile_sensor_data
        )
        self.publisher_ = self.create_publisher(String, '/stm32/joint', 10)
        
        self.current_j1_angle = 0.0
        self.J1_MIN_DEG = -90.0
        self.J1_MAX_DEG = 90.0

        # ===== íŒŒë¼ë¯¸í„° íŠœë‹ =====
        # ëª©í‘œëŠ” 4px ì´ë‚´ (ì•„ì£¼ ì—„ê²©í•¨)
        self.DEADBAND_PX = 4.0
        
        # ë°˜ì‘ì„± í–¥ìƒ
        self.alpha = 0.85
        
        self.BASE_SPEED = 1000
        self.CMD_INTERVAL = 0.04
        self.k_step = 0.005
        # =======================

        self.err_ema = 0.0
        self.ema_inited = False
        self.last_pub_time = 0.0
        self.state = 'IDLE'
        self.last_dist_print_time = 0.0
        self.base_angle = 0.0
        
        print("âœ… ì´ˆê¸°í™” ì™„ë£Œ. ì»µì„ ë³´ì—¬ì£¼ì„¸ìš”!")

    def publish(self, s: str):
        m = String()
        m.data = s
        self.publisher_.publish(m)

    def clamp(self, v, lo, hi):
        return lo if v < lo else hi if v > hi else v

    def camera_callback(self, msg: Point):
        now = time.time()
        if (now - self.last_pub_time) < self.CMD_INTERVAL:
            return

        err_x = float(msg.x)
        depth = float(msg.z)

        # íƒ€ê²Ÿ ë†“ì¹¨ ë°©ì§€
        if depth == -1.0 and err_x == 0.0:
            if self.state != 'IDLE':
                if (now - self.last_pub_time) > 0.5:
                     print("âš ï¸ íƒ€ê²Ÿ ë†“ì¹¨")
                     self.state = 'IDLE'
            return

        # EMA í•„í„°
        if not self.ema_inited:
            self.err_ema = err_x
            self.ema_inited = True
        else:
            self.err_ema = self.alpha * err_x + (1.0 - self.alpha) * self.err_ema

        e = self.err_ema

        # 1) ì •ë ¬ ì™„ë£Œ íŒë‹¨ (4.0px ì´ë‚´)
        if abs(e) <= self.DEADBAND_PX:
            if self.state != 'LOCKED':
                self.publish("STOP")
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                # ì„±ê³µí–ˆì„ ë•Œë§Œ ë¡œê·¸ ì¶œë ¥
                print(f"ğŸ¯ ì •ë°€ ì£¼ì°¨ ì„±ê³µ! [LOCKED] (Err: {e:.1f}px)")
                
                self.base_angle = self.current_j1_angle
                self.state = 'LOCKED'
                self.last_dist_print_time = now
            elif (now - self.last_dist_print_time) > 1.0:
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                print(f"ğŸ“ í˜„ì¬ ê±°ë¦¬: {dist_str}")
                self.last_dist_print_time = now
            
            self.last_pub_time = now
            return

        self.state = 'MOVING'

        # 2) ì´ë™ ë¡œì§
        angle_offset = e * self.k_step
        target_angle = self.base_angle + angle_offset
        target_angle = self.clamp(target_angle, self.J1_MIN_DEG, self.J1_MAX_DEG)
        self.current_j1_angle = target_angle

        # 3) â˜… í•µì‹¬ ìˆ˜ì •: ì†ë„ ì œì–´ (ë§ˆì°°ë ¥ ê·¹ë³µ) â˜…
        # ì˜¤ì°¨ê°€ ì‘ì•„ë„(ê°€ê¹Œì›Œì ¸ë„) í˜ì„ ë„ˆë¬´ ë¹¼ì§€ ì•ŠìŠµë‹ˆë‹¤.
        # ê¸°ì¡´: ê°€ê¹Œìš°ë©´ 200~300 -> ëª¨í„°ê°€ 'ì›…~' í•˜ê³  ì•ˆ ì›€ì§ì„
        # ìˆ˜ì •: ê°€ê¹Œì›Œë„ ìµœì†Œ 750ì˜ í˜ìœ¼ë¡œ ë°€ì–´ë¶™ì„
        
        dynamic_speed = int(self.BASE_SPEED + (1000 / (abs(e) + 1)) * 5)
        
        # ìµœì†Œ ì†ë„ë¥¼ 750ìœ¼ë¡œ ë†’ì—¬ì„œ "ë§ˆì§€ë§‰ 13px"ì„ ë°€ê³  ê°ˆ í˜ì„ ì¤ë‹ˆë‹¤.
        dynamic_speed = self.clamp(dynamic_speed, 750, 2500)

        cmd_str = f"T1 {target_angle:.3f} {dynamic_speed}"
        self.publish(cmd_str)
        self.last_pub_time = now

def main(args=None):
    rclpy.init(args=args)
    node = VisualServo()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
