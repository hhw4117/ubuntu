import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Point
from std_msgs.msg import String
from rclpy.qos import qos_profile_sensor_data
import time

print("âœ… [ì‹œìŠ¤í…œ] Visual Servo (ê³ ì† ë¹„ë¡€ ì œì–´ - ë“œë¦¬í”„íŠ¸ ì œê±°) ê°€ë™...")

class VisualServo(Node):
    def __init__(self):
        super().__init__('visual_servo_node')

        self.subscription = self.create_subscription(
            Point, '/camera/tracking', self.camera_callback, qos_profile_sensor_data
        )
        self.publisher_ = self.create_publisher(String, '/stm32/joint', 10)

        self.current_j1_angle = 0.0
        self.J1_MIN_DEG = -90.0
        self.J1_MAX_DEG = 90.0

        # ===== ê¸°ì¡´ íŠœë‹ íŒŒë¼ë¯¸í„° ìœ ì§€ =====
        self.DEADBAND_PX = 10.0
        self.BASE_SPEED = 1000
        self.CMD_INTERVAL = 0.04
        self.k_step = 0.005  # (ì´ ê°’ì€ ì´ì œ "deg/px ìŠ¤ì¼€ì¼"ë¡œ ì‚¬ìš©)

        self.alpha = 0.6
        self.err_ema = 0.0
        self.ema_inited = False

        self.last_pub_time = 0.0
        self.state = 'IDLE'
        self.last_dist_print_time = 0.0

        # âœ… ë“œë¦¬í”„íŠ¸ ì œê±°ìš©: "ê¸°ì¤€ ê°ë„"(LOCKEDì—ì„œ ê°±ì‹ )
        self.base_angle = 0.0

        print("âœ… ì´ˆê¸°í™” ì™„ë£Œ. ì»µì„ ë³´ì—¬ì£¼ì„¸ìš”!")

    def publish(self, s: str):
        m = String()
        m.data = s
        self.publisher_.publish(m)

    def clamp(self, v, lo, hi):
        return lo if v < lo else hi if v > hi else v

    def camera_callback(self, msg: Point):
        now = time.time()
        if (now - self.last_pub_time) < self.CMD_INTERVAL:
            return

        err_x = float(msg.x)
        depth = float(msg.z)

        # íƒ€ê²Ÿ ì—†ìŒ
        if depth == -1.0 and err_x == 0.0:
            if self.state != 'IDLE':
                print("âš ï¸ íƒ€ê²Ÿ ë†“ì¹¨")
                self.state = 'IDLE'
            return

        # EMA (ë…¸ì´ì¦ˆ ì œê±°)
        if not self.ema_inited:
            self.err_ema = err_x
            self.ema_inited = True
        else:
            self.err_ema = self.alpha * err_x + (1.0 - self.alpha) * self.err_ema
        e = self.err_ema

        # 1) ì •ë ¬ ì™„ë£Œ
        if abs(e) <= self.DEADBAND_PX:
            if self.state != 'LOCKED':
                self.publish("STOP")
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                print(f"ğŸ›‘ ì •ë ¬ ì™„ë£Œ! [ê±°ë¦¬: {dist_str}] (Err: {e:.1f})")

                # âœ… LOCKED ìˆœê°„ì˜ ëª©í‘œê°ì„ ê¸°ì¤€ê°ìœ¼ë¡œ ê³ ì • (ëˆ„ì  ë“œë¦¬í”„íŠ¸ ë°©ì§€)
                self.base_angle = self.current_j1_angle

                self.state = 'LOCKED'
                self.last_dist_print_time = now

            elif (now - self.last_dist_print_time) > 1.0:
                dist_str = f"{depth:.0f}mm" if depth > 0 else "ê±°ë¦¬ì¸¡ì •ë¶ˆê°€"
                print(f"ğŸ“ í˜„ì¬ ê±°ë¦¬: {dist_str}")
                self.last_dist_print_time = now

            self.last_pub_time = now
            return

        self.state = 'MOVING'

        # ============================================================
        # âœ… í•µì‹¬ ë³€ê²½: current_j1_angleì„ +=ë¡œ ëˆ„ì í•˜ì§€ ì•ŠìŒ
        # ëª©í‘œê°ì„ "ê¸°ì¤€ê° + ì˜¤ì°¨ë¹„ë¡€"ë¡œ ì§ì ‘ ê³„ì‚°
        # ============================================================

        # í”½ì…€ ì˜¤ì°¨ -> ê°ë„ ì˜¤ì°¨ë¡œ ë³€í™˜ (deg/px)
        # ê¸°ì¡´ k_stepì„ ê·¸ëŒ€ë¡œ ì¬ì‚¬ìš©(0.005ë©´ 100px -> 0.5ë„)
        angle_offset = e * self.k_step

        # ëª©í‘œê° = ê¸°ì¤€ê° + ì˜¤í”„ì…‹
        target_angle = self.base_angle + angle_offset

        # ëª©í‘œê° ì œí•œ
        target_angle = self.clamp(target_angle, self.J1_MIN_DEG, self.J1_MAX_DEG)

        # ë‚´ë¶€ ìƒíƒœë„ "ëª©í‘œê°"ìœ¼ë¡œ ë™ê¸°í™”(ë‹¤ìŒ LOCKED ë•Œ base_angle ê°±ì‹ ì„ ìœ„í•´)
        self.current_j1_angle = target_angle

        # ì†ë„ëŠ” ê¸°ì¡´ ë¡œì§ ìœ ì§€
        dynamic_speed = int(self.BASE_SPEED + (1000 / (abs(e) + 1)) * 5)
        if dynamic_speed > 2500:
            dynamic_speed = 2500
        if dynamic_speed < 500:
            dynamic_speed = 500

        cmd_str = f"T1 {target_angle:.3f} {dynamic_speed}"
        self.publish(cmd_str)

        self.last_pub_time = now

def main(args=None):
    rclpy.init(args=args)
    node = VisualServo()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
